/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0; you may not use this file except in compliance with the Elastic License
 * 2.0.
 */

import org.elasticsearch.gradle.Architecture
import org.elasticsearch.gradle.OS
import org.elasticsearch.gradle.Version
import org.elasticsearch.gradle.internal.BwcVersions
import org.elasticsearch.gradle.internal.test.AntFixture
import org.elasticsearch.gradle.testclusters.StandaloneRestIntegTestTask
import org.elasticsearch.gradle.transform.UnzipTransform
import static org.elasticsearch.gradle.PropertyNormalization.IGNORE_VALUE

apply plugin: 'elasticsearch.jdk-download'
apply plugin: 'elasticsearch.internal-testclusters'
apply plugin: 'elasticsearch.standalone-rest-test'
apply plugin: 'elasticsearch.rest-resources'

configurations {
  oldesFixture
}

dependencies {
  oldesFixture project(':test:fixtures:old-elasticsearch')
}

jdks {
  legacy {
    vendor = 'adoptium'
    version = '8u302+b08'
    platform = OS.current().name().toLowerCase()
    architecture = Architecture.current().name().toLowerCase()
  }
}

restResources {
  restApi {
    include '_common', 'search'
  }
  restTests {
    includeCore 'search/390_doc_values_search.yml'
  }
}

if (OS.current() == OS.MAC && Architecture.current() == Architecture.AARCH64) {
  jdks.legacy.vendor = 'zulu'
  jdks.legacy.distributionVersion = '8.56.0.23'
}

if (OS.current() == OS.WINDOWS) {
  logger.warn("Disabling repository-old-versions tests because we can't get the pid file on windows")
} else {
  project.getDependencies().registerTransform(UnzipTransform.class, transformSpec -> {
      transformSpec.getFrom().attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.ZIP_TYPE);
      transformSpec.getTo().attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE);
    }
  );
  // ------------------- First Cluster
  Version versionFirstCluster = Version.fromString('5.0.0')
  String packageName = 'org.elasticsearch.distribution.zip'
  String artifact = "${packageName}:elasticsearch:${versionFirstCluster}@zip"
  String versionNoDotsFirstCluster = versionFirstCluster.toString().replace('.', '_')
  String configNameFirstCluster = "es${versionNoDotsFirstCluster}"

  def configFirstCluster = configurations.create(configNameFirstCluster)
  configFirstCluster.getAttributes().attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE);
  dependencies.add(configNameFirstCluster, artifact)

  String repoLocationFirstCluster = "${buildDir}/cluster/shared/repo/${versionNoDotsFirstCluster}"
  String clusterNameFirstCluster= versionNoDotsFirstCluster

  def testClusterProviderFirstCluster = testClusters.register(clusterNameFirstCluster) {
    testDistribution = 'DEFAULT'
    numberOfNodes = 2
    versions = [project.version, project.version] // to test full cluster restart

    setting 'path.repo', repoLocationFirstCluster, IGNORE_VALUE
    setting 'xpack.license.self_generated.type', 'trial'

    setting 'xpack.security.enabled', 'true'
    user username: 'admin', password: 'admin-password', role: 'superuser'

    setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'
    setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'
  }

  TaskProvider<AntFixture> fixtureFirstCluster = tasks.register("oldES${versionNoDotsFirstCluster}Fixture", AntFixture) {
    dependsOn project.configurations.oldesFixture, jdks.legacy, configFirstCluster
    executable = "${buildParams.runtimeJavaHome.get()}/bin/java"
    env 'CLASSPATH', "${-> project.configurations.oldesFixture.asPath}"
    // old versions of Elasticsearch need JAVA_HOME
    env 'JAVA_HOME', jdks.legacy.javaHomePath
    // If we are running on certain arm systems we need to explicitly set the stack size to overcome JDK page size bug
    if (Architecture.current() == Architecture.AARCH64) {
      env 'ES_JAVA_OPTS', '-Xss512k'
    }
    def dataPath = "${baseDir}/data"
    args 'oldes.OldElasticsearch',
      baseDir,
      "${-> configFirstCluster.getSingleFile().toPath()}",
      false,
      "path.repo: ${repoLocationFirstCluster}",
      "path.data: ${dataPath}"
    if ((versionFirstCluster.onOrAfter('6.8.0') && Architecture.current() == Architecture.AARCH64) ||
      (versionFirstCluster.onOrAfter("6.4.0") && BwcVersions.isMlCompatible(versionFirstCluster) == false)) {
      // We need to explicitly disable ML when running old ES versions on ARM or on systems with newer GLIBC
      args 'xpack.ml.enabled: false'
    }
    doFirst {
      delete(dataPath)
      mkdir(dataPath)
    }
    maxWaitInSeconds 60
    waitCondition = { fixture, ant ->
      // the fixture writes the ports file when Elasticsearch's HTTP service
      // is ready, so we can just wait for the file to exist
      return fixture.portsFile.exists()
    }
  }

  // ------------------- Second
  Version versionSecondCluster = Version.fromString('6.0.0')
  packageName = 'org.elasticsearch.distribution.zip'
  artifact = "${packageName}:elasticsearch:${versionSecondCluster}@zip"
  String versionNoDotsSecondCluster = versionSecondCluster.toString().replace('.', '_')
  String configNameSecondCluster = "es${versionNoDotsSecondCluster}"

  def configSecondCluster = configurations.create(configNameSecondCluster)
  configSecondCluster.getAttributes().attribute(ArtifactTypeDefinition.ARTIFACT_TYPE_ATTRIBUTE, ArtifactTypeDefinition.DIRECTORY_TYPE);
  dependencies.add(configNameSecondCluster, artifact)

  String repoLocationSecondCluster = "${buildDir}/cluster/shared/repo/${versionNoDotsSecondCluster}"
  String clusterNameSecondCluster= versionNoDotsSecondCluster

  def testClusterProviderSecondCluster = testClusters.register(clusterNameSecondCluster) {
    testDistribution = 'DEFAULT'
    numberOfNodes = 2
    versions = [project.version, project.version] // to test full cluster restart

    setting 'path.repo', repoLocationSecondCluster, IGNORE_VALUE
    setting 'xpack.license.self_generated.type', 'trial'

    setting 'xpack.security.enabled', 'true'
    user username: 'admin', password: 'admin-password', role: 'superuser'

    setting 'xpack.searchable.snapshot.shared_cache.size', '16MB'
    setting 'xpack.searchable.snapshot.shared_cache.region_size', '256KB'
  }

  TaskProvider<AntFixture> fixtureSecondCluster = tasks.register("oldES${versionNoDotsSecondCluster}Fixture", AntFixture) {
    dependsOn project.configurations.oldesFixture, jdks.legacy, configSecondCluster
    executable = "${buildParams.runtimeJavaHome.get()}/bin/java"
    env 'CLASSPATH', "${-> project.configurations.oldesFixture.asPath}"
    // old versions of Elasticsearch need JAVA_HOME
    env 'JAVA_HOME', jdks.legacy.javaHomePath
    // If we are running on certain arm systems we need to explicitly set the stack size to overcome JDK page size bug
    if (Architecture.current() == Architecture.AARCH64) {
      env 'ES_JAVA_OPTS', '-Xss512k'
    }
    def dataPath = "${baseDir}/data"
    args 'oldes.OldElasticsearch',
      baseDir,
      "${-> configSecondCluster.getSingleFile().toPath()}",
      false,
      "path.repo: ${repoLocationFirstCluster}",
      "path.data: ${dataPath}"
    if ((versionSecondCluster.onOrAfter('6.8.0') && Architecture.current() == Architecture.AARCH64) ||
      (versionSecondCluster.onOrAfter("6.4.0") && BwcVersions.isMlCompatible(versionSecondCluster) == false)) {
      // We need to explicitly disable ML when running old ES versions on ARM or on systems with newer GLIBC
      args 'xpack.ml.enabled: false'
    }
    doFirst {
      delete(dataPath)
      mkdir(dataPath)
    }
    maxWaitInSeconds 60
    waitCondition = { fixture, ant ->
      // the fixture writes the ports file when Elasticsearch's HTTP service
      // is ready, so we can just wait for the file to exist
      return fixture.portsFile.exists()
    }
  }

  // ------------ Tasks
  tasks.register("javaRestTest", StandaloneRestIntegTestTask) {
    useCluster testClusterProviderFirstCluster
    useCluster testClusterProviderSecondCluster
    dependsOn fixtureFirstCluster
    dependsOn fixtureSecondCluster
    doFirst {
      delete(repoLocationFirstCluster)
      delete(repoLocationSecondCluster)
      mkdir(repoLocationFirstCluster)
      mkdir(repoLocationSecondCluster)
    }
  }

  tasks.matching { it.name.startsWith("javaRestTest")}.configureEach {
    it.nonInputProperties.systemProperty "tests.repo.location.first.cluster", repoLocationFirstCluster
    it.systemProperty "tests.es.version.first.cluster", versionFirstCluster.toString()

    it.nonInputProperties.systemProperty "tests.repo.location.second.cluster", repoLocationSecondCluster
    it.systemProperty "tests.es.version.second.cluster", versionSecondCluster.toString()

    /* Use a closure on the string to delay evaluation until right before we
     * run the integration tests so that we can be sure that the file is
     * ready. */
    it.nonInputProperties.systemProperty "tests.es.port.first.cluster", "${-> fixtureFirstCluster.get().addressAndPort}"
    it.nonInputProperties.systemProperty "tests.es.port.second.cluster", "${-> fixtureSecondCluster.get().addressAndPort}"

    it.nonInputProperties.systemProperty('tests.rest.cluster', "${-> testClusterProviderFirstCluster.get().allHttpSocketURI.join(",")}")
    it.nonInputProperties.systemProperty('tests.clustername', "${-> testClusterProviderFirstCluster.get().getName()}")
  }
}

